# Лабораторная работа 2. Регистры и счётчики

Функции цифровых устройств, естественно, не сводятся к реализации разнообразных ФАЛ. Нам хотелось бы использовать цифровые устройства для обработки информации, вычислений. Но для осуществления этих возможностей нам недостаёт элемента памяти, который мог бы хранить промежуточные результаты. Ведь невозможно сделать калькулятор, если нет возможности сохранить вводимые числа и результат вычисления.

Элемент памяти — один из самых важных элементов цифровых устройств. Чтобы не делать ошибок при разработке цифровых устройств, необходимо понять место этого узла, его идею и инструменты языка SystemVerilog, связанные с ним.

Первый элемент памяти, который мы рассмотрим — это  RS-**защелка** (англ. latch).

Защелка является основой всех элементов памяти. Она состоит из двух элементов И-НЕ (или из двух элементов ИЛИ-НЕ, в зависимости от базиса, выбранного при проектировании), соединенных по следующей схеме:


![Структура RS-защелки](./pic/RS_latch.svg)

У защелки два входа и два выхода. Входами являются сигналы "сброс" и "установка в единицу" или по-английски "reset" и "set", откуда и происходит её название. В зависимости от элементов, из которых состоит защелка, полярность входных сигналов будет меняться. В базисе И-НЕ сброс и установка происходят, когда соответственно сигналы R или S находятся в нуле, поэтому их обозначают как "не-сброс" и "не-установка", чтобы отразить этот факт. Выход защелки — это тот бит данных, который она хранит. Два выхода отличаются полярностью — один из них инвертирует хранимый бит. Ниже приведена таблица со всеми возможными комбинациями входных сигналов и временная диаграмма работы защелки. Стоит обратить внимание на состояние, где оба управляющих сигнала выставлены в 0 (для базиса ИЛИ-НЕ будет 1). Это некорректное, запрещенное состояние. Во-первых, основной и инверсный выходы становятся одинаковыми, что нарушает их суть. Во-вторых, после выхода из этого состояния (например, переход в хранение хранение) поведение защелки неопределено. Неизвестно, на каком из выходов элемента выставится 1, а на каком 0. В общем и целом, туда лучше не попадать.

RS-защелка с И-НЕ базисом
| `S` | `R` | `Q` | `~Q`|
|-----|-----|-----|-----|
| 0   | 0   | 1   | 1   |
| 0   | 1   | 1   | 0   |
| 1   | 0   | 0   | 1   |
| 1   | 1   | Q   | ~Q  |
 
![Временная диаграмма работы RS-защелки с И-НЕ базисом](./pic/rs_timing.png)

Опишем защелку на языке SystemVerilog, опираясь на её структуру, которую мы рассмотрели выше. Нам понадобятся два входа, два выхода и два элемента И-НЕ, которые мы опишем с помощью операций И (оператор `&`) и НЕ (оператор `~`).

Описание RS-защелки на языке SystemVerilog
```systemverilog
module latch_struct(
  input  logic nR,
  input  logic nS,
  output logic Q,
  output logic nQ
);

assign Q = ~(nS & nQ);
assign nQ = ~(nR & Q);

endmodule
```

Элемент памяти нам, прежде всего, нужен для хранения данных. Для того, чтобы защелкой стало удобнее пользоваться, немного изменим схему подключения управляющих сигналов и превратим RS-защёлку в D-защёлку.

![Структура D-защелки](./pic/D_latch.svg)

Защелка теперь будет работать следующим образом: при высоком уровне на входе "разрешить работу" (enable) данные со входа "данные" (data) будут проходить через защелку на выход, при низком уровне на входе "разрешить работу" защелка будет сохранять на выходе последнее значение со входа "данные", которое было до переключения сигнала "разрешить работу". Работа такой защелки показана на временной диаграмме ниже.

![Временная диаграмма работы D-защелки](./pic/d_timing.png)

Как мы уже говорили, использовать структурные описания не всегда удобно. В большинстве случаев использовать поведенческое описание намного эффективнее. Поведенческое описание часто формулируется гораздо лаконичнее, и, так как его легче понять человеку, улучшается читаемость кода и уменьшается вероятность ошибок при его написании.

Поведенческое описание D-защелки на языке SystemVerilog
```systemverilog
module d_latch_behav(
  input  logic d,
  input  logic en,
  output logic q
);

always_latch begin
  if (en)
    q <= d;
end

endmodule
```

Если добавить к этой схеме еще две защелки, то можно привязать изменение "содержимого" защелки к переходу управляющего сигнала из `0` в `1`. Тогда получим следующую структуру:


![Структура D-триггера](./pic/dff_struct.svg)


Эту схему можно немного доработать, введя управляющие сигналы сброса, установки в единицу и разрешения работы. Упрощенно такая схема изображается следующим образом.

![Графическое обозначение D-триггера](./pic/dff.svg)

Эта схема получила широчайшее применение в цифровой схемотехнике и называется D-триггер (от слова "data" — данные). Ниже приведена временная диаграмма работы D-триггера.

![Пример работы D-триггера](./pic/d_timing2.png)

Заметим, что сигнал `clk` называют **тактирующим** сигналом или "сигналом синхронизации". Обычно в роли этого сигнала выступает сигнал от внешнего источника (чаще всего кварцевого резонатора) со стабильной частотой. А сами цифровые устройства, для работы которых необходим сигнал синхронизации, называют синхронными.

Сигнал синхронизации играет очень большую роль в цифровых устройствах. Прежде всего, он необходим для того, чтобы избежать непредсказуемого и нестабильного поведения триггеров в цифровых устройствах.

Описание D-триггера на языке SystemVerilog
```systemverilog
module d_flipflop_behav(
  input  logic clk,
  input  logic rst,
  input  logic d,
  input  logic en,
  output logic q
);

always_ff @(posedge clk or posedge rst) begin
  if (rst)
    q <= 0;
  else if (en)
    q <= d;
end

endmodule

```


В описании появилось новое ключевое слово `posedge`. Оно используется только в списке чувствительности блока `always_ff` и означает событие перехода сигнала, имя которого стоит после этого ключевого слова, из состояния `0` в состояние `1`.

Ключевое слово `posedge` было введено прежде всего для того, чтобы описывать схемы, содержащие триггеры. Ведь триггеры, как мы уже говорили, могут менять своё состояние только в момент положительного фронта (англ. positive edge) сигнала синхронизации.

Таким образом можно отметить разницу между защёлкой и триггером. Защёлка работает по уровню управляющего сигнала, обновляя выход в любой момент, пока активен сигнал. Триггер - по фронту, изменяя выход только по определенному событию.

Добавление в список чувствительности события `posedge rst` позволяет описать поведение триггера в момент асинхронного сброса: как только случается переход rst из `0` в `1` срабатывает блок `always_ff` и проверка условия `if (rst)` дает положительный результат, триггер сбрасывается в `0`.

Если объединить несколько триггеров в группу, то получится то, что в цифровой схемотехнике называют **регистр**.

Описание регистра на языке SystemVerilog
```systemverilog
module register_behav(
  input  logic       clk,
  input  logic       rst,
  input  logic [7:0] d,
  input  logic       en,
  output logic [7:0] q
);

always_ff @(posedge clk or posedge rst) begin
  if (rst)
    q <= 0;
  else if (en)
    q <= d;
end

endmodule

```

Элементы памяти позволяют нам сохранять информацию для дальнейшей обработки или хранить готовый результат вычисления, хранить промежуточные результаты.

Запомните описание регистра. Оно используется при проектировании практически любого цифрового устройства с помощью SystemVerilog.

Необходимо отметить важную концепцию языка SystemVerilog. **Один сигнал может быть изменен (записан) только в пределах одного блока always. Сигналы доступны для проверки в любом из блоков, но изменять их значение можно только в одном из них.**



Пример ошибочного присвоения значения переменной в разных блоках `always_ff` на языке SystemVerilog
```systemverilog
logic a;
logic b;

always_ff @(posedge clk) begin
  if (in < 5)
    a <= in;
end

always_ff @(posedge clk) begin
  if (n > 5) begin
    b <= in;
    a <= in - 5; // Error!
  end else begin
    b <= a;
  end
end

```

Одной из простейших и в тоже время широко распространённой цифровой схемой на основе регистров является счётчик.

Счётчик считает количество тактов, которое прошло с момента его обнуления.

Такая простая схема, тем не менее, используется практически в каждом цифровом устройстве. Как будет показано дальше, счётчик легко можно доработать таким образом, чтобы отсчитывались не такты, а какие-то события. Например, событиями могут быть: нажатие кнопки, принятие пакета данных, срабатывание датчика, выполнение какого-то условия (периодическое) и другое.

Итак, для того, чтобы реализовать счетчик, нам понадобится регистр и сумматор. Причем сумматор будет складывать значение, хранящееся в регистре, с константой (в нашем случае, с единицей), а результат сложения будет поступать на вход регистра.

В результате получим следующую схему:

![Структура восьмибитного счетчика](./pic/counter.svg)

На временной диаграмме ниже хорошо видно как работает счётчик (прим. - на диаграмме выход count во время EN переключается с некоторой задержкой относительно предшествующего ему фронта тактового сигнала):

![Пример работы счётчика](./pic/counter_timing.png)

Опишем поведение такого счётчика на SystemVerilog.

Описание восьмибитного счетчика на языке SystemVerilog
```systemverilog
module counter_8bit(
  input  logic       clk,
  input  logic       rst,
  input  logic       en,
  output logic [7:0] counter
);

always_ff @(posedge clk or posedge rst) begin
  if (rst)
    counter <= 0;
  else if (en)
    counter <= counter + 1;
end

endmodule

```

Для того, чтобы можно было подсчитывать события, а не переходы сигнала синхронизации из `0` в `1`, понадобится ввести еще одну схему. Её смысл и назначение заключается в следующем: нам необходимо из асинхронного события получить синхронный сигнал единичной длительности. Тогда, подавая такой сигнал на вход enable счётчика, мы сможем считать количество произошедших событий.

Базовым примером необходимости подобного решения является фиксация события по кнопке (например, на вашем стенде FPGA). В данном случае необходимо добиться трёх вещей: единичность события, отсутствие метастабильности, отсутствие дребезга.

1. Единичность события.
Стенд FPGA, предположим, работает на частоте 100МГц. Вы нажали кнопку. Данное действие займёт у вас примерно 100 мс. Если не предпринимать никаких мер, то счетчик вместого того, чтобы выдасть единицу, выдаст на выходе 100,000,000 МГц * 0.1 с = 10 млн. Думаю, погрешность в 10,000,000% нас не устроит. В таком случае вводится схема, генерирующая единичный импульс длиною в период такта. 

Ниже представлена схема, позволяющая сделать это:

![Схема выработки синхронного импульса из асинхронного события](./pic/pulse_gen.svg)

2. Отсутствие метастабильности.
Если не вдаваться в подробности, то у регистров, как физических ячеек, есть некоторые параметры, определямые их изготовлением на заводе (они индивидуальны после производства, но предсказуемые и лежат в определенном промежутке, характеризованным заводом). Параметры задают промежуток, в течение которого данные на входе регистра должны быть стабильны (не изменятся) *до* фронта тактового сигнала (его называются setup); и промежуток, в течение которого данные на входе регистра должны быть стабильны *после* фронта тактового сигнала (его называют hold). Почему важно держать стабильными данные в этих промежутках? Дело в том, что данные на выходе регистра не перейдут в определенное состояние, а биты соответствующей шины будут колебаться между 0 и 1. Подобное поведение называется метастабильностью и природой лежит в схемотехническом и технологическом устройстве регистра. В нашем примере, можно нажать кнопку так близко к тактовому сигналу, что счетчик может сработать несколько раз или не сработает вовсе.

Схемы, предотвращающие подобное, называются синхронизаторами/пересинхронизаторами. Тема обширная и в подавляющем большинстве рассматривается при изучении темы CDC (Clock Domain Crossing). Простейшая и базовая же схема сихнронизатора - это несколько в ряд стоящих регистров (обычно 2). Давайте используем синхронизатор на входе генератора пульса.

![Схема выработки синхронного импульса из пересинхронизированного асинхронного события](./pic/register.svg)

![Временная диаграмма работы схемы синхронизации](./pic/sync_timing.png)

Описание схемы синхронизации на языке SystemVerilog

```systemverilog
module button_sync(
  input  logic clk,
  input  logic in,
  output logic out
);

  logic [2:0] button_synchroniser;
  logic       button_was_pressed;

  always_ff @(posedge clk) begin
    button_synchroniser[0] <= in;
    button_synchroniser[1] <= button_synchroniser[0];
    button_synchroniser[2] <= button_synchroniser[1];
  end

  assign button_was_pressed = ~button_synchroniser[2]
                            &  button_synchroniser[1];

  assign out = button_was_pressed;

endmodule

```

3. Отсутствие дребезга.
Механическая кнопка в связи со своей конструкцией (например, упругусть элементов) при нажатии не просто переходит в состояние логической "1", но перед этим колеблится между двумя уровнями. Данный процесс представн на схеме ниже.

![Пример дребезга кнопки](./pic/bounce_example.png)

Поскольку период подобных всплесков держится в основном 1-10 мс, высокочастотная схема засчитает не одно переключение, а несколько. В таком случае, нужно проверить, что выставленный сигнал держится не несколько мс, а какое-то время, которое мы признаем как действительное для детектирования. Ниже приведена схема такого блока. На входе уже известный синхронизатор из двух регистров. Далее - сама схема. Если происходит переключение, то счетчик сбрасывается и начинает свой счёт. Как только происходит переполнение - значит необходимое время прошло и можно записать значение. В конце схемы стоит уже известный генератор синхросигнала.

![Пример дребезга кнопки](./pic/full_debounce.svg)

Естественно такая схема работает только тогда, когда входной сигнал изменяется с частотой меньшей, чем частота синхронизации.

Сигнал `OUT` подключается к входу `EN` счётчика.

## Задание лабораторной работы

Описать на языке SystemVerilog цифровое устройство, функционирующее согласно следующим принципам:

1. Ввод информации происходит с переключателей `SW[9:0]` и кнопок `KEY[0]`, `KEY[1]`. Внешний источник сигнала синхронизации: `CLOCK_50`;
2. `KEY[1]` должна функционировать как общий асинхронный сброс устройства;
3. При нажатии на `KEY[0]` записывать данные с `SW[9:0]` в десятибитный регистр;
4. Содержимое десятибитного регистра выводить на `LEDR[9:0]`;
5. При нажатии на `KEY[0]` увеличивать 8-ми разрядный счётчик нажатий на 1, если произошло событие, указанное в индивидуальном задании студента;
6. Содержимое счётчика выводить в шестнадцатеричной форме на HEX0 и HEX1 (цифры с 0 до 9 и буквы A, B, C, D, E, F)

Выполнив описание модуля на языке SystemVerilog, необходимо построить временные диаграммы его работы с помощью САПР Altera Quartus.

Привязать входы модуля к переключателям SW отладочной платы, а выход к шине `HEX0[6:0]`, получить прошивку для ПЛИС и продемонстрировать её работу.

## Пример индивидуального задания

Событием является наличие 3 и более единиц на `SW[9:0]` в момент записи в регистр.

Решение индивидуального задания (фрагмент кода лабораторной работы)

```systemverilog
logic sw_event;
always_comb begin
  if ((SW[0] + SW[1] + SW[2] + SW[3]
     + SW[4] + SW[5] + SW[6] + SW[7]
     + SW[8] + SW[9]) > 4'd3) sw_event = 1'b1;
  else sw_event = 1'b0;
end

logic [2:0] event_sync_reg;
logic       synced_event;
assign synced_event =  event_sync_reg[1]
                    & ~event_sync_reg[0];

always_ff @(posedge CLK50) begin
  event_sync_reg[2]   <= sw_event;
  event_sync_reg[1:0] <= event_sync_reg[2:1];
end

```





## Варианты индивидуальных заданий

1.    Событие:
      Количество сочетаний «01» на переключателях `SW[9:0]` не менее 4.

2.    Событие:
      Количество переключателей `SW[9:0]` в положении «1» не менее 5.

3.    Событие:
      На переключателях закодировано число больше 10, но меньше 20.

4.    Событие:
      Четное количество переключателей `SW[9:0]` в положении «1». (нуль – четное число)

5.    Событие:
      Симметрия переключателей `SW[9:0]` относительно середины.

6.    Событие:
      Число на `SW[9:5]` больше числа на `SW[4:0]` как минимум в 2 раза.

7.    Событие:
      Асимметрия переключателей `SW[9:0]` относительно центра.

8.    Событие:
      Количество сочетаний «101» на переключателях не менее 2.

9.    Событие:
      Количество переключателей `SW[9:0]` в положении «1» не более 3.

10.   Событие:
      Нечетное количество переключателей `SW[9:0]` в положении «1».


## Вопросы к защите лабораторной работы

  1. Какие элементы памяти вы изучили в данной лабораторной работе?
  2. Чем отличается RS-защелка от D-защелки?
  3. Какие входы могут быть у триггера? Перечислите все и назовите их функции.
  4. Какие блоки вашего цифрового устройства синхронные? Какие нет? Почему?
  5. Какой фрагмент вашего кода описывает вывод значения счетчика на семисегментный индикатор? Как называется эта цифровая схема?
  6. Продемонстрируйте код, реализующий индивидуальное задание.
  7. Покажите в коде лабораторной работы код, реализующий счётчик.
  8. Что такое сигнал синхронизации?
